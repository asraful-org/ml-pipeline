name: CI/CD for ML Model and Inference API

on:
  push:
    branches:
      - main
  workflow_dispatch: # Allows manual trigger

# Define reusable environment variables for the workflow ###
# These will be available to all jobs and steps unless overridden
env:
  # Azure ML Workspace Details (used by train.py and app.py)
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  AZURE_RESOURCE_GROUP_NAME: ${{ secrets.AZURE_RESOURCE_GROUP_NAME }}
  AZURE_ML_WORKSPACE_NAME: ${{ secrets.AZURE_ML_WORKSPACE_NAME }}

  # Inference API Specifics (used by app.py)
  REGISTERED_MODEL_NAME: "IrisLogisticRegressionModel" # This should match what's in src/train.py
  MODEL_VERSION: "latest" # Or a specific version number, e.g., "1"

  # Azure Container Registry (ACR) Details
  ACR_NAME: "modleregistry" # <<<< REPLACE with your ACR name (e.g., 'youruniqueregnam')
  IMAGE_NAME: "iris-inference-api"
  IMAGE_TAG: "latest" # Or consider using github.sha for unique image builds

  # Azure Container Instance (ACI) Details
  ACI_RESOURCE_GROUP: "ml-pipeline-dev" # <<<< REPLACE with your ACI Resource Group
  ACI_NAME: "iris-api-instance" # <<<< REPLACE with your desired ACI instance name
  ACI_PORT: 5001 # Port your Flask app exposes

  # Azure API Management (APIM) Details
  APIM_RESOURCE_GROUP: "ml-pipeline-dev" # <<<< REPLACE with your APIM Resource Group
  APIM_SERVICE_NAME: "ml-api-management-rg" # <<<< REPLACE with your existing APIM service name
  APIM_API_ID: "iris-inference-api" # <<<< REPLACE with a unique ID for the API in APIM (e.g., 'iris-classifier')
  APIM_API_DISPLAY_NAME: "Iris Classifier API"
  APIM_API_SUFFIX: "iris" # The suffix for the API URL in APIM (e.g., /iris)

jobs:
  train_model:
    name: ML Model Training and Tracking to Azure ML
    runs-on: ubuntu-latest

    permissions:
      id-token: write # Required for OIDC
      contents: read

    env: # These are specific to the train_model job's env block
      AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      AZURE_RESOURCE_GROUP_NAME: ${{ secrets.AZURE_RESOURCE_GROUP_NAME }}
      AZURE_ML_WORKSPACE_NAME: ${{ secrets.AZURE_ML_WORKSPACE_NAME }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login (for DefaultAzureCredential - OIDC)
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set up Python environment
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install azure-ai-ml azure-identity mlflow # Ensure mlflow is installed

      - name: Run ML training and log with MLflow
        run: |
          python src/train.py

      - name: Upload model.pkl as GitHub Actions artifact (optional)
        uses: actions/upload-artifact@v4
        with:
          name: trained-model-pkl
          path: model.pkl
          retention-days: 7
        if: success()

  build_push_docker_image:
    needs: train_model
    runs-on: ubuntu-latest
    permissions: # Each job needs its own id-token write permission for OIDC
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Azure Login (for ACR push - OIDC)
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }} # Use top-level env var for subscription-id

      - name: Azure Container Registry Docker Login # <--- THIS IS THE MISSING CRITICAL STEP
        # This command uses the Azure CLI context set by `azure/login` to authenticate Docker
        # The Service Principal (via OIDC) MUST have AcrPush (and AcrPull) roles on the ACR.
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build and push Docker image to ACR
        uses: docker/build-push-action@v5
        with:
          context: .
          file: inference_api/Dockerfile
          push: true
          tags: ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
        env:
            AZURE_SUBSCRIPTION_ID: ${{ env.AZURE_SUBSCRIPTION_ID }}
            AZURE_RESOURCE_GROUP_NAME: ${{ env.AZURE_RESOURCE_GROUP_NAME }}
            AZURE_ML_WORKSPACE_NAME: ${{ env.AZURE_ML_WORKSPACE_NAME }}
            REGISTERED_MODEL_NAME: ${{ env.REGISTERED_MODEL_NAME }}
            MODEL_VERSION: ${{ env.MODEL_VERSION }}

  deploy_to_aci:
    needs: build_push_docker_image
    runs-on: ubuntu-latest
    environment: production
    permissions: # Each job needs its own id-token write permission for OIDC
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login (for ACI deployment - OIDC)
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy to Azure Container Instances
        id: deployaci
        uses: azure/aci-deploy@v1
        with:
          resource-group: ${{ env.ACI_RESOURCE_GROUP }}
          name: ${{ env.ACI_NAME }}
          image: ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          dns-name-label: iris-api-${{ github.run_id }}
          port: ${{ env.ACI_PORT }}
          # CORRECTED: Use KEY=VALUE format for environment-variables
          environment-variables: |
            AZURE_SUBSCRIPTION_ID=${{ env.AZURE_SUBSCRIPTION_ID }}
            AZURE_RESOURCE_GROUP_NAME=${{ env.AZURE_RESOURCE_GROUP_NAME }}
            AZURE_ML_WORKSPACE_NAME=${{ env.AZURE_ML_WORKSPACE_NAME }}
            REGISTERED_MODEL_NAME=${{ env.REGISTERED_MODEL_NAME }}
            MODEL_VERSION=${{ env.MODEL_VERSION }} # Corrected line 117

      - name: Get ACI FQDN and Construct API URL
        run: |
          sleep 10 # Give ACI a moment to provision and get FQDN
          RETRIES=5
          ACI_FQDN=""
          for i in $(seq 1 $RETRIES); do
              ACI_FQDN=$(az container show \
                --resource-group ${{ env.ACI_RESOURCE_GROUP }} \
                --name ${{ env.ACI_NAME }} \
                --query ipAddress.fqdn \
                --output tsv 2>/dev/null)
              if [ -n "$ACI_FQDN" ]; then
                  echo "Found ACI FQDN: ${ACI_FQDN}"
                  break
              fi
              echo "ACI FQDN not yet available, retrying in 10 seconds..."
              sleep 10
          done

          if [ -z "$ACI_FQDN" ]; then
              echo "Failed to retrieve ACI FQDN after multiple retries. Exiting."
              exit 1
          fi

          ACI_URL="http://${ACI_FQDN}:${{ env.ACI_PORT }}"
          echo "ACI_URL=${ACI_URL}" >> $GITHUB_ENV

      - name: Wait for ACI to be ready
        run: |
          echo "Waiting for ACI to become available at ${{ env.ACI_URL }}/..."
          timeout 300 bash -c 'until curl -sS ${{ env.ACI_URL }}/ > /dev/null; do sleep 10; done'
          echo "ACI is ready."

  update_api_management:
    needs: deploy_to_aci
    runs-on: ubuntu-latest
    permissions: # Each job needs its own id-token write permission for OIDC
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login (for APIM update - OIDC)
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Update or Create API in API Management
        run: |
          ACI_BACKEND_URL="${{ env.ACI_URL }}"
          echo "APIM Backend URL will be: ${ACI_BACKEND_URL}"

          API_EXISTS=$(az apim api show \
            --resource-group ${{ env.APIM_RESOURCE_GROUP }} \
            --service-name ${{ env.APIM_SERVICE_NAME }} \
            --api-id ${{ env.APIM_API_ID }} \
            --query name \
            --output tsv 2>/dev/null)

          if [ -z "$API_EXISTS" ]; then
            echo "API '${{ env.APIM_API_ID }}' does not exist. Creating new API..."
            az apim api create \
              --resource-group ${{ env.APIM_RESOURCE_GROUP }} \
              --service-name ${{ env.APIM_SERVICE_NAME }} \
              --api-id ${{ env.APIM_API_ID }} \
              --display-name "${{ env.APIM_API_DISPLAY_NAME }}" \
              --path ${{ env.APIM_API_SUFFIX }} \
              --protocols Http \
              --service-url "${ACI_BACKEND_URL}/"
          else
            echo "API '${{ env.APIM_API_ID }}' exists. Updating its backend URL..."
            az apim api update \
              --resource-group ${{ env.APIM_RESOURCE_GROUP }} \
              --service-name ${{ env.APIM_SERVICE_NAME }} \
              --api-id ${{ env.APIM_API_ID }} \
              --service-url "${ACI_BACKEND_URL}/"
          fi

          echo "API Management update complete for API ID: ${{ env.APIM_API_ID }}"
          echo "Backend URL set to: ${ACI_BACKEND_URL}"